<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 官网学习记录 | bory博客</title>
    <meta name="description" content="Just playing around">


    <link rel="preload" href="/assets/css/0.styles.6d1f88be.css" as="style">
    <link rel="preload" href="/assets/js/app.09e16acc.js" as="script">
    <link rel="preload" href="/assets/js/2.5d5850e3.js" as="script">
    <link rel="preload" href="/assets/js/5.31e42fd2.js" as="script">
    <link rel="prefetch" href="/assets/js/3.718fcc25.js">
    <link rel="prefetch" href="/assets/js/4.95ad132b.js">
    <link rel="prefetch" href="/assets/js/6.71254ee9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6d1f88be.css">
</head>

<body>
    <div id="app" data-server-rendered="true">
        <div class="theme-container no-sidebar">
            <header class="navbar">
                <div class="sidebar-button">
                    <!-- <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img"
                        viewBox="0 0 448 512" class="icon">
                        <path fill="currentColor"
                            d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z">
                        </path>
                    </svg> -->
                </div> <a href="/" class="home-link router-link-exact-active router-link-active">
                    <!----> <span class="site-name">bory博客</span></a>
                <div class="links">
                    <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value="">
                        <!---->
                    </div>
                    <nav class="nav-links can-hide">
                        <div class="nav-item"><a href="https://github.com/BoryLee" target="_blank"
                                rel="noopener noreferrer" class="nav-link external">
                                github
                                <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px"
                                    viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                                    <path fill="currentColor"
                                        d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                                    </path>
                                    <polygon fill="currentColor"
                                        points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                                    </polygon>
                                </svg></a></div>
                        <!---->
                    </nav>
                </div>
            </header>
            <div class="sidebar-mask"></div>
            <aside class="sidebar">
                <nav class="nav-links">
                    <div class="nav-item"><a href="https://github.com/BoryLee" target="_blank" rel="noopener noreferrer"
                            class="nav-link external">
                            github
                            <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px"
                                viewBox="0 0 100 100" width="15" height="15" class="icon outbound">
                                <path fill="currentColor"
                                    d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z">
                                </path>
                                <polygon fill="currentColor"
                                    points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9">
                                </polygon>
                            </svg></a></div>
                    <!---->
                </nav>
                <!---->
            </aside>
            <main class="page">
                <div class="theme-default-content content__default">
                    <h1 id="react-官网学习记录"><a href="#react-官网学习记录" class="header-anchor">#</a> React 官网学习记录</h1>
                    <h2 id="特性"><a href="#特性" class="header-anchor">#</a> 特性</h2>
                    <ul>
                        <li>React元素是不可变对象。一旦被创建就无法更高它的子元素或者属性。</li>
                    </ul>
                    <h2 id="组件-props"><a href="#组件-props" class="header-anchor">#</a> 组件&amp;Props</h2>
                    <blockquote>
                        <p>组件，类似于Javacript函数。它接受任意的入参，并返回用于描述页面展示内容的React元素。</p>
                    </blockquote>
                    <h3 id="函数组件与class组件"><a href="#函数组件与class组件" class="header-anchor">#</a> 函数组件与class组件</h3>
                    <h3 id="渲染组件"><a href="#渲染组件" class="header-anchor">#</a> 渲染组件</h3>
                    <blockquote>
                        <p>当React元素为用户自定义组件时，它会将JSX所接收的属性转换为单个对象传递给组件，这个对象被称之为“props”。</p>
                    </blockquote>
                    <div class="language-javascript extra-class">
                        <pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">Welcome</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello<span class="token punctuation">,</span> <span class="token punctuation">{</span>props<span class="token punctuation">.</span>name<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> element <span class="token operator">=</span> <span class="token operator">&lt;</span>Welcome name<span class="token operator">=</span><span class="token string">&quot;Sara&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
        element<span class="token punctuation">,</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
</code></pre>
                    </div>
                    <div class="language- extra-class">
                        <pre class="language-text"><code>  1.我们调用ReactDOM.render()函数，并传入&lt;Welcome name=&quot;Sara&quot;/&gt;作为参数;
  2.React调用Welcome组件，并将{name:&quot;Sara&quot;}作为props传入;
  3.Welcome组件将&lt;h1&gt;Hello,Sara&lt;/h1&gt;元素作为返回值;
  ReactDOM将DOM高效地更新为&lt;h1&gt;Hello,Sara&lt;/h1&gt;。
</code></pre>
                    </div>
                    <h3 id="props的只读性"><a href="#props的只读性" class="header-anchor">#</a> Props的只读性</h3>
                    <blockquote>
                        <p>组件无论是使用函数声明还是通过class声明，都绝不能修改自身的props。
                            纯函数：不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。</p>
                    </blockquote>
                    <p><strong>所有React组件都必须像纯函数一样保护它们props不被更改</strong></p>
                    <h2 id="state-生命周期"><a href="#state-生命周期" class="header-anchor">#</a> State &amp; 生命周期</h2>
                    <blockquote>
                        <p>state是私有的，并且完全受控于当前组件</p>
                    </blockquote>
                    <h3 id="正确使用state"><a href="#正确使用state" class="header-anchor">#</a> 正确使用State</h3>
                    <h4 id="不要直接修改state"><a href="#不要直接修改state" class="header-anchor">#</a> 不要直接修改State</h4>
                    <blockquote>
                        <p>构造函数是唯一可以给this.state赋值的地方</p>
                    </blockquote>
                    <h3 id="state的更新可能是异步的"><a href="#state的更新可能是异步的" class="header-anchor">#</a> State的更新可能是异步的</h3>
                    <blockquote>
                        <p>出于性能考虑，React可能会把多个setState()调用合并成一个调用。因为this.props和this.state可能会异步更新，所以不要依赖他们的值来更新下一个状态</p>
                    </blockquote>
                    <div class="language-javascript extra-class">
                        <pre class="language-javascript"><code>下面的代码可能会无法更新计数器
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        count<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>counter <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>increment
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">要解决这个问题，可以让setState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>接收一个函数而不是一个对象。这个函数用上一个state作为第一个参数，将此次更新被应用时的props作为第二个参数
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>props</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
       count<span class="token operator">:</span> tate<span class="token punctuation">.</span>counter <span class="token operator">+</span> props<span class="token punctuation">.</span>increment  
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    或者
     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span>props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token punctuation">{</span>
           count<span class="token operator">:</span> tate<span class="token punctuation">.</span>counter <span class="token operator">+</span> props<span class="token punctuation">.</span>increment  
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
                    </div>
                    <h3 id="state的更新会被合并"><a href="#state的更新会被合并" class="header-anchor">#</a> State的更新会被合并</h3>
                    <blockquote>
                        <p>当你调用setState()的时候，React会把你提供的对象合并到当前的state</p>
                    </blockquote>
                    <div class="language-javascript extra-class">
                        <pre class="language-javascript"><code>    当state包含几个独立的变量：
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
            posts<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
            comments<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token function">然后可以分别表用setState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>来单独地更新它们：
    <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                posts<span class="token operator">:</span> res<span class="token punctuation">.</span>posts
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">fetchComments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                comments<span class="token operator">:</span> res<span class="token punctuation">.</span>comments
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    这里的合并是浅合并，所以<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>comments<span class="token punctuation">}</span><span class="token punctuation">)</span>完整保留了<span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>posts<span class="token punctuation">,</span>但是完全替换了<span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>comments
</code></pre>
                    </div>
                    <h3 id="数据是向下流动的"><a href="#数据是向下流动的" class="header-anchor">#</a> 数据是向下流动的</h3>
                    <p><code>不管是父组件或者是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关系它是函数组件还是class组件。这就是为什么称state为局部的或是封装的原因。除了拥有并设置了它的组件，其他组件都无法访问。</code>
                    </p>
                    <h2 id="事件处理"><a href="#事件处理" class="header-anchor">#</a> 事件处理</h2>
                    <ul>
                        <li>React事件的命名采用小驼峰式，而不是纯小写</li>
                        <li>使用JSX语法时需要传入一个函数作为事件处理函数，而不是一个字符串</li>
                    </ul>
                    <h3 id="向时间处理程序传递参数"><a href="#向时间处理程序传递参数" class="header-anchor">#</a> 向时间处理程序传递参数</h3>
                    <div class="language-javascript extra-class">
                        <pre class="language-javascript"><code><span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteRow</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Delete Row<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteRow</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Delete Row<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
在这两种情况下，React的事件对象e会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过bind的方式，事件对象以及更多的参数将会被隐式的进行传递
</code></pre>
                    </div>
                    <h2 id="状态提升"><a href="#状态提升" class="header-anchor">#</a> 状态提升</h2>
                    <blockquote>
                        <p>通常，多个组件需要反映相同的变化数据，这时建议将共享状态提升到最近的共同的父组件中去。</p>
                    </blockquote>
                    <h2 id="context"><a href="#context" class="header-anchor">#</a> context</h2>
                    <blockquote>
                        <p>context提供了一个无需为每层组件手动添加props,就能在组件树间进行数据传递的方法</p>
                    </blockquote>
                    <h3 id="何时使用context"><a href="#何时使用context" class="header-anchor">#</a> 何时使用context</h3>
                    <blockquote>
                        <p>context设计的目的是为了共享那些对于一个组件树而言是“全局”的数据。</p>
                    </blockquote>
                    <h2 id="refs转发"><a href="#refs转发" class="header-anchor">#</a> Refs转发</h2>
                    <blockquote>
                        <p>Ref转发是一项将ref自动地通过组件传递到其一子组件的技巧。Ref转发是一个可选特性，其允许某些组件接收ref，并将其向下传递给子组件</p>
                    </blockquote>
                    <h2 id="高阶组件-hoc"><a href="#高阶组件-hoc" class="header-anchor">#</a> 高阶组件 HOC</h2>
                    <blockquote>
                        <p>高阶组件是React中用于复用组件了逻辑的一种高级技巧。HOC自身不是React API的一部分，它是一种基于React的组合特性而形成的设计模式。
                            具体而言，高阶组件是参数为组件，返回值为新组件的函数
                            const EnhancedComponent = higherOrderComponent(WrappedComponent);
                            组件是将props转换为UI，而高阶组件是将组件转换为另一个组件</p>
                    </blockquote>
                    <h2 id="深入jsx"><a href="#深入jsx" class="header-anchor">#</a> 深入JSX</h2>
                    <p>**实际上，JSX仅仅只是React.createElement(component,props,...children)函数的语法糖</p>
                    <h2 id="portals"><a href="#portals" class="header-anchor">#</a> Portals</h2>
                    <p><strong>Portal提供了一种将子节点渲染到存在于父组件以外的DOM节点的优秀的方案</strong></p>
                    <div class="language-javascript extra-class">
                        <pre class="language-javascript"><code>    ReactDOM<span class="token punctuation">.</span><span class="token function">createPortal</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span>container<span class="token punctuation">)</span><span class="token punctuation">;</span>
    第一个参数child是任何可渲染的React子元素。第二个参数是一个<span class="token constant">DOM</span>元素
</code></pre>
                    </div>
                    <h3 id="用法"><a href="#用法" class="header-anchor">#</a> 用法</h3>
                    <p>通常来讲，当从组件的render方法返回一个元素时，该元素将被挂载到DOM节点中离其最近的父节点</p>
                    <h2 id="profiler-api"><a href="#profiler-api" class="header-anchor">#</a> Profiler API</h2>
                    <p><strong>Profiler测量渲染一个React应用多久渲染一次以及渲染一次的“代价”</strong></p>
                    <h3 id="用法-2"><a href="#用法-2" class="header-anchor">#</a> 用法</h3>
                    <p>Profiler能添加在React树中的
                        任何地方来测量树中这部分渲染所带来的开销。它需要两个prop:一个是id，一个是当组件树中的组件“提交”更新的时候被React调用的回调函数onRender(function)</p>
                    <h2 id="不使用es6"><a href="#不使用es6" class="header-anchor">#</a> 不使用ES6</h2>
                    <blockquote>
                        <p>创建组件的方法：声明式组件、函数式组件、createReactClass</p>
                    </blockquote>
                    <h2 id="协调"><a href="#协调" class="header-anchor">#</a> 协调</h2>
                    <h3 id="设计动力"><a href="#设计动力" class="header-anchor">#</a> 设计动力</h3>
                    <p>在某一事件节点调用React的render()方法，会创建一个由React元素组成的树。在下一次state或props更新时，相同的render()方法会返回一棵不同的树，React需要基于这两棵树之间的差别来判断如何有效的更新UI已办证当前UI与最新的树保持同步，React算法：
                    </p>
                    <ul>
                        <li>两个不同类型的元素会产生不同的树；</li>
                        <li>开发者可以通过key prop来暗示哪些子元素在不同的渲染下能保持稳定</li>
                    </ul>
                    <h3 id="diffing算法"><a href="#diffing算法" class="header-anchor">#</a> Diffing算法</h3>
                    <p>当对比两棵树时，React首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态</p>
                    <h4 id="比对不同类型的元素"><a href="#比对不同类型的元素" class="header-anchor">#</a> 比对不同类型的元素</h4>
                    <p>当根节点为不同类型的元素时，React会拆卸原有的树并且建立起新的树。
                        当拆卸一棵树时，对应的DOM节点也会被销毁。组件实例将执行componentWillUnmount()方法。当建立一棵新的树时，对应的DOM节点会被创建以及插入得到DOM中。组件实例将执行componentWillMount()方法，紧跟着componentDidMount()方法。所有跟之前的树所关联的state也会被销毁。
                        在根节点以下的组件也会被卸载，它们的状态会被销毁。</p>
                    <h4 id="比对同一类型的元素"><a href="#比对同一类型的元素" class="header-anchor">#</a> 比对同一类型的元素</h4>
                    <p>当比对两个相同类型的React元素时，React会保留DOM节点，仅比对及更新有改变的属性</p>
                </div>
                <footer class="page-edit">
                    <!---->
                    <!---->
                </footer>
                <!---->
            </main>
        </div>
        <div class="global-ui"></div>
    </div>
    <script src="/assets/js/app.09e16acc.js" defer></script>
    <script src="/assets/js/2.5d5850e3.js" defer></script>
    <script src="/assets/js/5.31e42fd2.js" defer></script>
</body>

</html>
